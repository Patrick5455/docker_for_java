command to deploy a volume from localhost to contianer path:

IN: sudo docker run -d --name webapp -p 8080:8080 -v `pwd`/webapp.war:/opt/jboss/wildfly/standalone/deployments/webapp.war/ jboss/wildfly
out: 6b9d35e1ea275605c248cb61237513271f04c064a423d164969badd6e23a1cf1

Confirm the artifact has been deployed to the container in the specified port. So we run/visit the url in the browser

IN: curl http://localhost:8080/webapp/resources/persons

OUT:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?><collection><person><name>Penny</name></person><person><name>Leonard</name></person><person><name>Sheldon</name></person><person><name>Amy</name></person><person><name>Howard</name></person><person><name>Bernadette</name></person><person><name>Raj</name></person><person><name>Priya</name></person></collection>patrick@patrick:~/Documents/dev/personal/learning_path/devops/gupta_docker/docker-for-java-master/chap

Building a DOcker image
To build a docker image, we use a dockerfile which contains some steps (started by FROM) to create our image

1. First, you create a diorectory where the image would be built
2. THen you create a file named 'Dockerfile'. This file contains the steps/instructions you want docker to use in buidling your image.
> Steps/instructions in Dockerfile include

# FROM - this is always the first step. It tells docker which base image to pull form. Typically we pull from an existing image to creat our own image

# CMD - docker containers run only one thing which they run really well. This is what we specofy in the CMD step. We specify what we want this image container(s) torun

# COPY - docker copies new files or directoires from the host to the continaer filesystem

# ADD - does what COPY does but in addition does file auto-extraciton in the image

3. After creating the Dockerfile, we build the image with the following command

IN: docker build -t <imagename:imagetag> <path of Dockerfile or use . if it is int he CWD>

OUT: 
Sending build context to Docker daemon  2.048kB
Step 1/2 : FROM ubuntu
latest: Pulling from library/ubuntu
6a5697faee43: Pull complete 
ba13d3bc422b: Pull complete 
a254829d9e55: Pull complete 
Digest: sha256:fff16eea1a8ae92867721d90c59a75652ea66d29c05294e6e2f898704bdb8cf1
Status: Downloaded newer image for ubuntu:latest
 ---> d70eaf7277ea
Step 2/2 : CMD echo "hello world"
 ---> Running in 6636a271271e
Removing intermediate container 6636a271271e
 ---> 83acd232dd3c
Successfully built 83acd232dd3c
Successfully tagged helloworld:latest

By default, if we do not specify a tag for our image, Docker uses the latest tag

4. You can also specify a .dockerignore file to ignore files you dont' want to be added to your image from the directory where the Dockerfile is located


5. Now we can run a simlple container from the image we just built.

IN: docker run --name <container_name> <image_name>

>docker history <image_name> - this gives us the histroy of an image

When building an image, there are several oither tags we can add to the build command, e.g;

> --compress : to compress files from the build context/directory and send to the host in a gzip format


The alpine tag helps us to pull images version with lower size. alpine tags are smaller in size than toher tags expecoally latest tags


To add a java project (jar/war) to our images, we can use the COPY in our dockerfile.
So we will specify the name of the file to be copied inside the directory we are creating the image and the specify the location in the image(base image) we want it to be located

e.g 

FROM jboss/wildfly

COPY webapp.war /opt/jboss/wildfly/standlaone/deployments/webapp.war

Note that, there is no CMD in the Dockerfile above. This is becuase in cases of multiple dockerfiles intheriting from each other, only one CMD will everb effective. The child Dockerfile CMD overrides the parent CMD. Also if we have multiple CMD in one DOckerfile, only the last CMD will be effective
